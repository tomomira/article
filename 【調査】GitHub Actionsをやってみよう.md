# 【調査】GitHub ActionsでGemini CLIを使ってみよう

このドキュメントは、[Zennの記事](https://zenn.dev/makumaaku/articles/15f56ac617a3af) を参考に、GitHub ActionsでGemini CLIをセットアップして利用するまでの手順と関連知識をまとめたものです。

---

## 1. 基本的なコンセプト

### ReActループとは？
AIが複雑なタスクを解決するための思考フレームワークです。「Reasoning（推論）」と「Acting（行動）」を組み合わせた言葉で、以下のサイクルを繰り返します。

1.  **推論 (Reasoning):** 次に何をすべきか考える。
2.  **行動 (Acting):** 考えに基づいてツール利用や情報検索などの行動を起こす。
3.  **観察 (Observation):** 行動結果を観察し、次の推論の材料にする。

このサイクルにより、AIは自律的にタスクを分析し、問題を解決することができます。

---

## 2. セットアップ手順

### 手順1：前提条件の準備
まず、Gemini CLIをGitHub Actionsで利用するために必要なものを準備します。

#### 1. Gemini CLI のインストール
- ターミナルからGeminiを利用するための公式ツールです。
- GitHub連携機能を使うには、**v0.1.16以上**が必要です。

#### 2. GitHubリポジトリにAPIキーを設定する
- **`GEMINI_API_KEY`**（GeminiのAPIを利用するための認証キー）をGitHubに安全に登録します。
- **場所**: 連携したいリポジトリの `Settings` → `Secrets and variables` → `Actions`
- **設定方法**:
    1. `New repository secret` ボタンをクリックします。
    2. **`Secrets`** を選択します（`Variables`は機密情報向けではないため使いません）。
    3. `Name`に `GEMINI_API_KEY` と入力します。
    4. `Secret`に、[Google AI Studio](https://aistudio.google.com/app/apikey) などで取得したAPIキーを貼り付けます。
    5. `Add secret` ボタンで保存します。

> **補足**: `Repository secrets` はリポジトリ全体で、 `Environment secrets` は特定の環境（本番/テストなど）で使えます。今回はシンプルな `Repository secrets` を使います。

### 手順2：Gemini CLIとGitHubリポジトリの連携
ローカルPCのターミナルで、**初回に一度だけ**以下のコマンドを実行します。

```bash
gemini /setup-github
```

- このコマンドを実行すると、ブラウザが起動しGitHubアカウントでの認証が求められます。
- 画面の指示に従い、Gemini CLIにアクセスを許可したいリポジトリを選択します。
- **別のリポジトリを追加したい場合**: 再度コマンドを実行する必要はありません。GitHubの `Settings` → `Applications` から、Gemini CLIに許可するリポジトリを変更できます。

### 手順3：ワークフロー定義ファイルの作成
AIに実行させたいタスクを定義するファイルを作成します。この作業はローカルのリポジトリ内で行います。

1.  ローカルのプロジェクトフォルダ内に `.github/workflows` という階層でフォルダを作成します。
2.  `workflows` フォルダ内に `gemini.yml` などのYAMLファイルを作成します。
3.  ファイルに、記事の例のようなワークフローを記述します。

    ```yaml
    name: Gemini CLI Agent
    on:
      pull_request:
        types: [opened, synchronize, reopened]
      issues:
        types: [opened]

    jobs:
      gemini:
        runs-on: ubuntu-latest
        permissions:
          contents: read
          pull-requests: write
          issues: write
        steps:
          - uses: actions/checkout@v4
          - uses: google-github-actions/run-gemini-cli@v0
            with:
              gemini_api_key: ${{ secrets.GEMINI_API_KEY }}
              workflow: pr-review # or issue-triage / on-demand
    ```
4.  このファイルを `git push` してGitHubに反映させると、`on:`で指定したイベント（IssueやPRの作成など）をトリガーに、自動で処理が実行されるようになります。

---

## 3. 代表的なユースケース

### IssueとPull Request(PR)の基本
- **Issue（イシュー）**: プロジェクトの掲示板や課題管理表のようなもの。バグ報告や機能要望など、**話し合いや報告**に使います。コードの変更は伴わず、主にGitHubのサイト上で作成します。
- **Pull Request（プルリクエスト, PR）**: 「このコード変更を取り込んでください」という**提案**。必ず**コードの変更**が伴い、ローカルでのコマンド操作とGitHubサイトでの操作を組み合わせて作成します。

### ユースケース1：自動Issue Triage（Issueの自動仕分け）
- **概要**: 投稿されたIssueの内容をAIが読み取り、`bug` `enhancement` `high-priority` のようなラベルを自動で付けてくれる機能。
- **メリット**: 開発チームがIssueを整理する手間が省け、対応の優先順位がつけやすくなります。

### ユースケース2：PRコードレビュー
- **概要**: 開発者が作成したPull RequestのコードをAIが人間より先にチェックし、改善点や問題点を自動でコメントしてくれる機能。
- **メリット**: 簡単なミスをAIが即座に指摘するため、人間のレビュー担当者はより本質的なレビューに集中でき、開発速度が向上します。

### ユースケース3：On-demandタスク委譲
- **概要**: IssueやPRのコメント欄で `@gemini-cli` とメンションをつけて話しかけることで、AIに作業を依頼できる機能。
- **例**: `@gemini-cli この変更に対するテストコードを書いてください` とコメントすると、AIがテストコードを自動生成してくれます。
- **メリット**: テストコード作成などの定型作業をAIに任せ、開発者はより創造的な作業に集中できます。

---

## 4. GitHub Actionsで自動化できる手動作業の例

開発ワークフローにおいて、GitHub Actionsは以下のような多岐にわたる手動作業を自動化できます。

### 1. コードの品質管理
-   **コードフォーマットの整形**: `Prettier` や `Black` などのツールを使い、コードのスタイルを統一します。
-   **静的コード解析 (リンティング)**: `ESLint` や `RuboCop` などで、文法エラーや潜在的なバグを自動で検出します。
-   **セキュリティ脆弱性スキャン**: `Snyk` や `Dependabot` などを利用し、コードや利用しているライブラリに既知の脆弱性がないかチェックします。
-   **AIによるコードレビュー**: Pull Requestが作成された際に、AIが自動でコードをレビューし、改善点をコメントします。
-   **コードカバレッジの計測**: テストがソースコードのどれくらいの範囲をカバーしているかを計測し、結果をレポートします。

### 2. ビルドとテスト
-   **コンパイルとビルド**: ソースコードをコンパイルし、実行可能なファイルや配布用のパッケージを生成します。
-   **単体テスト・結合テストの実行**: コードが変更されるたびに、定義されたテストを自動で実行し、バグの混入（デグレード）を防ぎます。
-   **E2E (End-to-End) テスト**: 実際のユーザー操作を模したテストをブラウザ上で自動実行し、システム全体の動作を保証します。
-   **複数環境でのテスト**: Windows, macOS, Linuxなど、異なるOSや、複数のバージョンのプログラミング言語でテストを自動実行します。

### 3. リリースとデプロイ
-   **コンテナイメージの作成とプッシュ**: `Dockerfile` を使ってアプリケーションをコンテナ化し、Docker Hubなどのレジストリに自動で保存します。
-   **アプリケーションのデプロイ**: テストを通過したコードを、ステージング環境や本番環境のサーバーへ自動で反映させます。
-   **パッケージの公開**: 作成したライブラリを `npm` や `PyPI` などのパッケージ管理システムに自動で公開します。
-   **リリースノートの自動生成**: コミット履歴やPull Requestの情報を元に、新しいバージョンの変更点をまとめたリリースノートを自動で作成します。
-   **インフラのプロビジョニング**: `Terraform` や `CloudFormation` を使い、サーバーやデータベースなどのインフラ環境をコードベースで自動構築・更新します。

### 4. プロジェクト管理とコミュニケーション
-   **Issue/PRへのラベル付け**: 作成されたIssueやPull Requestの内容を解析し、「バグ」「機能追加」といったラベルを自動で付与します。
-   **通知**: ビルドの失敗やデプロイの完了といったイベントを、SlackやMicrosoft Teamsなどのチャットツールに自動で通知します。
-   **ドキュメントの生成**: コード内のコメントからAPIドキュメントを自動で生成し、Webサイトとして公開します。

これらの作業を自動化することで、手作業によるミスを防ぎ、開発プロセス全体の速度と信頼性を大幅に向上させることができます。
